# ==============================================================================
#  Julia Script: Overlapping Liquidity Baskets (AMO Model)
# ==============================================================================

using Dynare
using CSV
using DataFrames

MOD_FILENAME = "AMO_model.mod"
OUTPUT_FOLDER = "output"

# --- GLOBAL VARIABLE INITIALIZATION ---

ALL_VARS = String[]

# ==============================================================================
#  SECTION 1: CONFIGURATION
# ==============================================================================

# A. SIMULATION & IRF SETTINGS
SIM_PERIODS = 300   
BURN_IN     = 100   
IRF_HORIZON = 20    
# B. BASKET MAPPING (Binary: 1 = Asset in Basket)
MARKET_MAP = [
    1 1 1 0 0 ;  # Basket 1
    0 0 1 1 1    # Basket 2
]

# C. PARAMETERS
GLOBAL_PARAMS = Dict(
    # --- Consumer Preferences ---
    "beta"   => 0.99,   # Discount factor (time preference)
    "sigma"  => 2.0,    # Risk aversion coefficient (curvature of consumption utility)
    "gamma"  => 2.0,    # Curvature parameter for liquidity utility function
    
    # --- Liquidity Parameters ---
    "psi"    => 0.5,    # Weight on liquidity in utility (relative to consumption)
    "eta"    => 1.5,    # Elasticity of substitution across asset groups
    
    # --- Endowment ---
    "y"      => 1.0,    # Steady-state consumption endowment
    
    # --- Shock Process Parameters ---
    "rho_G"  => 0.9,    # Persistence of supply shocks (omega_G)
    "sig_G"  => 0.01,   # Std dev of supply shock innovations
    "rho_a"  => 0.9,    # Persistence of preference shocks (omega_a)
    "sig_a"  => 0.01    # Std dev of preference shock innovations
)

BASKET_RHO     = [10.0, 2.0]
BASKET_DELTA   = [0.2, 0.8]
BASKET_WEIGHTS = [0.5, 0.5]

ASSET_SUPPLY_BAR = [2.0, 2.0, 1.0, 0.5, 0.5] 
ASSET_PHI        = [0.1, 0.1, 0.2, 1.5, 1.5] 
ASSET_DELTA_IDIO = [0.1, 0.1, 0.5, 0.9, 0.9] 

# ==============================================================================
#  SECTION 2: GENERATION LOGIC
# ==============================================================================

N_BASKETS, N_ASSETS = size(MARKET_MAP)
BASKET_ALPHA_BAR = BASKET_WEIGHTS ./ sum(BASKET_WEIGHTS)

# Reset list
empty!(ALL_VARS)

open(MOD_FILENAME, "w") do io
    println("Generating $MOD_FILENAME...")
    
    # Use global to ensure we populate the top-level list
    global ALL_VARS

    # A. VARIABLES
    write(io, "// Generated by Julia\nvar L c\n")
    push!(ALL_VARS, "L", "c")
    
    for i in 1:N_ASSETS
        write(io, "    omega_G_$i omega_a_$i\n")
        push!(ALL_VARS, "omega_G_$i", "omega_a_$i")
    end
    for k in 1:N_BASKETS
        write(io, "    L_k$k alpha_k$k omega_a_basket_$k\n")
        push!(ALL_VARS, "L_k$k", "alpha_k$k", "omega_a_basket_$k")
    end
    for i in 1:N_ASSETS
        write(io, "    R_$i\n")
        push!(ALL_VARS, "R_$i")
    end
    for k in 1:N_BASKETS
        for i in 1:N_ASSETS
            if MARKET_MAP[k,i] == 1
                write(io, "    b_$(i)_k$(k) alpha_$(i)_k$(k)\n")
                push!(ALL_VARS, "b_$(i)_k$(k)", "alpha_$(i)_k$(k)")
            end
        end
    end
    
    write(io, ";\n\nvarexo\n")
    for i in 1:N_ASSETS;  write(io, "    eps_G_$i eps_a_$i\n"); end
    for k in 1:N_BASKETS; write(io, "    eps_a_basket_$k\n"); end
    write(io, ";\n\nparameters\n")
    
    # B. PARAMETERS & CALIBRATION
    for (k,v) in GLOBAL_PARAMS; write(io, "    $k\n"); end
    for k in 1:N_BASKETS; write(io, "    rho_k$k alpha_bar_k$k delta_k$k\n"); end
    for i in 1:N_ASSETS;  write(io, "    b_bar_$i phi_$i delta_idio_$i\n"); end
    for k in 1:N_BASKETS
        for i in 1:N_ASSETS
            if MARKET_MAP[k,i] == 1; write(io, "    alpha_bar_$(i)_k$(k)\n"); end
        end
    end
    write(io, ";\n\n// CALIBRATION\n")
    for (k,v) in GLOBAL_PARAMS; write(io, "$k = $v;\n"); end
    for k in 1:N_BASKETS
        write(io, "rho_k$k = $(BASKET_RHO[k]); alpha_bar_k$k = $(BASKET_ALPHA_BAR[k]); delta_k$k = $(BASKET_DELTA[k]);\n")
    end
    for i in 1:N_ASSETS
        write(io, "b_bar_$i = $(ASSET_SUPPLY_BAR[i]); phi_$i = $(ASSET_PHI[i]); delta_idio_$i = $(ASSET_DELTA_IDIO[i]);\n")
    end
    for k in 1:N_BASKETS
        n_in = sum(MARKET_MAP[k,:])
        w_val = 1.0 / n_in
        for i in 1:N_ASSETS
            if MARKET_MAP[k,i] == 1; write(io, "alpha_bar_$(i)_k$(k) = $w_val;\n"); end
        end
    end

    # C. MODEL BLOCK
    write(io, "\nmodel;\n    c = y;\n")
    for i in 1:N_ASSETS
        write(io, "    omega_G_$i = rho_G * omega_G_$i(-1) + sig_G * eps_G_$i;\n")
        write(io, "    omega_a_$i = rho_a * omega_a_$i(-1) + sig_a * eps_a_$i;\n")
    end
    for k in 1:N_BASKETS
        write(io, "    omega_a_basket_$k = rho_a * omega_a_basket_$k(-1) + sig_a * eps_a_basket_$k;\n")
    end
    
    terms_L = ["(alpha_k$k * L_k$k^((eta-1)/eta))" for k in 1:N_BASKETS]
    write(io, "    L = ( " * join(terms_L, " + ") * " )^(eta/(eta-1));\n")

    for k in 1:N_BASKETS
        terms_Lk = []
        for i in 1:N_ASSETS
            if MARKET_MAP[k,i] == 1; push!(terms_Lk, "(alpha_$(i)_k$(k) * b_$(i)_k$(k)^((rho_k$k-1)/rho_k$k))"); end
        end
        write(io, "    L_k$k = ( " * join(terms_Lk, " + ") * " )^(rho_k$k/(rho_k$k-1));\n")
    end

    denom_k_str = join(["(alpha_bar_k$j * exp(delta_k$j * omega_a_basket_$j))" for j in 1:N_BASKETS], " + ")
    for k in 1:N_BASKETS
        write(io, "    alpha_k$k = (alpha_bar_k$k * exp(delta_k$k * omega_a_basket_$k)) / ($denom_k_str);\n")
    end

    for k in 1:N_BASKETS
        denom_ik_str = join(["(alpha_bar_$(j)_k$(k) * exp(delta_idio_$j * omega_a_$j))" for j in 1:N_ASSETS if MARKET_MAP[k,j]==1], " + ")
        for i in 1:N_ASSETS
            if MARKET_MAP[k,i] == 1
                num = "(alpha_bar_$(i)_k$(k) * exp(delta_idio_$i * omega_a_$i))"
                write(io, "    alpha_$(i)_k$(k) = $num / ($denom_ik_str);\n")
            end
        end
    end

    for i in 1:N_ASSETS
        lhs = "b_bar_$i + phi_$i * omega_G_$i"
        rhs = join(["b_$(i)_k$(k)" for k in 1:N_BASKETS if MARKET_MAP[k,i]==1], " + ")
        write(io, "    $lhs = $rhs;\n")
    end

    for k in 1:N_BASKETS
        for i in 1:N_ASSETS
            if MARKET_MAP[k,i] == 1
                lhs = "1 - beta * R_$i"
                rhs = "(psi / c^(-sigma)) * (alpha_k$k * alpha_$(i)_k$(k)) * L^(1/eta - gamma) * L_k$k^(1/rho_k$k - 1/eta) * b_$(i)_k$(k)^(-1/rho_k$k)"
                write(io, "    $lhs = $rhs;\n")
            end
        end
    end
    write(io, "end;\n\n")

    # D. INIT & SOLVE
    write(io, "initval;\n    c = y; L = 1.0;\n")
    for i in 1:N_ASSETS;  write(io, "    omega_G_$i = 0; omega_a_$i = 0;\n"); end
    for k in 1:N_BASKETS; write(io, "    omega_a_basket_$k = 0;\n"); end
    for i in 1:N_ASSETS
        share = ASSET_SUPPLY_BAR[i] / sum(MARKET_MAP[:,i])
        write(io, "    R_$i = 1.0/beta - 0.005;\n")
        for k in 1:N_BASKETS
            if MARKET_MAP[k,i] == 1
                write(io, "    b_$(i)_k$(k) = $share; alpha_$(i)_k$(k) = $(1.0/sum(MARKET_MAP[k,:]));\n")
            end
        end
    end
    for k in 1:N_BASKETS; write(io, "    L_k$k = 1.0; alpha_k$k = $(BASKET_ALPHA_BAR[k]);\n"); end
    write(io, "end;\n\n")

    write(io, "shocks;\n")
    for i in 1:N_ASSETS;  write(io, "    var eps_G_$i = 1; var eps_a_$i = 1;\n"); end
    for k in 1:N_BASKETS; write(io, "    var eps_a_basket_$k = 1;\n"); end
    write(io, "end;\n\nsteady;\ncheck;\n")
    write(io, "stoch_simul(order=1, drop=$BURN_IN, periods=$SIM_PERIODS, irf=$IRF_HORIZON, graph_format=pdf);\n")
end
println("Success! Created $MOD_FILENAME")

# ==============================================================================
#  SECTION 3: EXECUTION & EXPORT
# ==============================================================================

println("\n--- Running Dynare ---")
global context = @dynare "AMO_model.mod"
if !isdir(OUTPUT_FOLDER); mkdir(OUTPUT_FOLDER); end

# --- PART A: UNIVERSAL IRF EXPORT ---
println("\n--- Exporting IRFs ---")
try
    local model_res = context.results.model_results[1]
    local irf_dict  = model_res.irfs
    local organized_data = Dict{String, DataFrame}()
    
    for (dict_key, dict_val) in irf_dict
        local shock_name = string(dict_key)
        local data_matrix = Matrix(dict_val)
        local col_names
        
        # Robust Name Extraction
        if hasproperty(dict_val, :names)
            col_names = string.(dict_val.names)
        else
            col_names = string.(propertynames(dict_val))
        end

        for (i, var_name) in enumerate(col_names)
            if i > size(data_matrix, 2); continue; end
            
            if !haskey(organized_data, var_name)
                organized_data[var_name] = DataFrame("Period" => 1:size(data_matrix, 1))
            end
            organized_data[var_name][!, shock_name] = data_matrix[:, i]
        end
    end
    
    for (var_name, df) in organized_data
        select!(df, sort(names(df)))
        CSV.write(joinpath(OUTPUT_FOLDER, "Response_$(var_name).csv"), df)
    end
    println("✔ Saved IRFs")

catch e
    println("❌ Error processing IRFs: $e")
end

# --- PART B: SIMULATION EXPORT ---
println("\n--- Exporting Simulation Data ---")
try
    # Define local variables to satisfy soft scope rules
    local raw_data = nothing
    
    # 1. Try Standard Path
    if hasproperty(context.results.model_results[1], :simulations)
        local sim_obj = context.results.model_results[1].simulations[1]
        raw_data = Matrix(sim_obj.data)
        println("✔ Found data in model_results...simulations")
        
    # 2. Try Fallback Path (context.results.endo_simul)
    elseif hasproperty(context.results, :endo_simul)
        raw_data = context.results.endo_simul
        println("✔ Found data in context.results.endo_simul")
    else
        error("Could not locate simulation data.")
    end
    
    # 3. Handle Orientation
    local sim_data
    if size(raw_data, 1) < size(raw_data, 2)
        sim_data = raw_data' # Transpose to [Time x Vars]
    else
        sim_data = raw_data
    end

    # 4. Headers (Using ALL_VARS)
    # Use global ALL_VARS to ensure we get the list from the generator
    local final_headers
    if size(sim_data, 2) == length(ALL_VARS)
        final_headers = ALL_VARS
    else
        println("⚠️ Mismatch: Data has $(size(sim_data, 2)) cols, ALL_VARS has $(length(ALL_VARS)).")
        final_headers = ["Var$i" for i in 1:size(sim_data, 2)]
    end
    
    # 5. Save
    local df_sim = DataFrame(sim_data, final_headers)
    CSV.write(joinpath(OUTPUT_FOLDER, "Simulation_Cleaned.csv"), df_sim)
    println("✔ Saved Simulation_Cleaned.csv")
    
catch e
    println("❌ Simulation Export failed.")
    println(e)
end

println("\n✔ DONE.")