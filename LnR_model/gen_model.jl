# ==============================================================================
#  Julia Script: Fully Parameterized Liquidity Model Generator
#  Method: Standard Linearization
# ==============================================================================

# --- 1. USER CONFIGURATION (CONTROL PANEL) ------------------------------------

const MOD_FILENAME = "LnR_model.mod"

# A. STRUCTURE
const ASSETS_PER_GROUP = [3, 2, 2]

# B. GLOBAL PARAMETERS
const GLOBAL_PARAMS = Dict(
    "beta"  => 0.99, "sigma" => 2.0, "psi" => 0.5, "gamma" => 2.0, "eta" => 1.5, "y" => 1.0,
    "rho_G" => 0.9, "sig_G" => 0.01, "rho_a" => 0.9, "sig_a" => 0.01
)

# C. GROUP PARAMETERS
const GROUP_RHO = [10.0, 2.0, 4.0]
const GROUP_DELTA = [0.2, 0.8, 0.5]
const GROUP_WEIGHTS_RAW = [0.7, 0.3, 0.4]

# D. ASSET PARAMETERS
const ASSET_SUPPLY = [
    [2.0, 2.0, 2.0],  # Group 1
    [0.5, 0.5],       # Group 2
    [1.0, 1.0]        # Group 3
]

const ASSET_PHI = [
    [0.1, 0.3, 0.2],  # Group 1
    [1.0, 1.5],       # Group 2
    [0.7, 0.5]        # Group 3
]

const ASSET_DELTA = [
    [0.2, 0.3, 0.1],  # Group 1
    [0.9, 0.9],       # Group 2
    [0.6, 0.4]        # Group 3
]

const ASSET_WEIGHTS_RAW = [
    [1.0, 1.2, 1.7],  # Group 1
    [3.0, 2.0],       # Group 2
    [0.5, 1.6]        # Group 3
]


# ==============================================================================
#  LOGIC (DO NOT EDIT BELOW THIS LINE)
# ==============================================================================

# --- Derived Constants ---
const N_GROUPS = length(ASSETS_PER_GROUP)
const TOTAL_ASSETS = sum(ASSETS_PER_GROUP)

# --- Helper Functions ---
function get_group_range(k)
    start_idx = sum(ASSETS_PER_GROUP[1:k-1]) + 1
    end_idx   = start_idx + ASSETS_PER_GROUP[k] - 1
    return start_idx:end_idx
end

function get_asset_group(flat_index)
    current_count = 0
    for k in 1:N_GROUPS
        if flat_index <= current_count + ASSETS_PER_GROUP[k]; return k; end
        current_count += ASSETS_PER_GROUP[k]
    end
    error("Index error")
end

function get_local_index(flat_index)
    k = get_asset_group(flat_index)
    return flat_index - (sum(ASSETS_PER_GROUP[1:k-1]))
end

function build_summation(indices, term_generator)
    terms = String[]
    for i in indices; push!(terms, term_generator(i)); end
    return join(terms, " + ")
end

# --- Normalization ---
const GROUP_ALPHA_BAR = GROUP_WEIGHTS_RAW ./ sum(GROUP_WEIGHTS_RAW)
const ASSET_ALPHA_BAR = [ w ./ sum(w) for w in ASSET_WEIGHTS_RAW ]

# --- Generation ---

open(MOD_FILENAME, "w") do io
    println("Generating $MOD_FILENAME (No Yield Variable)...")

    # A. PREAMBLE
    write(io, "// Generated by Julia - Standard Linearization\n")
    write(io, "var L c\n")
    
    for i in 1:TOTAL_ASSETS; write(io, "    omega_G_$i omega_a_$i\n"); end
    for k in 1:N_GROUPS; write(io, "    L_k$k alpha_k$k omega_a_group_$k\n"); end
    
    # CHANGED: Removed Yield_$i
    for i in 1:TOTAL_ASSETS; write(io, "    b_$i R_$i alpha_ik_$i\n"); end
    write(io, ";\n\n")

    write(io, "varexo\n")
    for i in 1:TOTAL_ASSETS; write(io, "    eps_G_$i eps_a_$i\n"); end
    for k in 1:N_GROUPS; write(io, "    eps_a_group_$k\n"); end
    write(io, ";\n\n")

    # B. PARAMETERS
    write(io, "parameters\n")
    for (k,v) in GLOBAL_PARAMS; write(io, "    $k\n"); end
    for k in 1:N_GROUPS; write(io, "    rho_k$k alpha_bar_k$k delta_k$k\n"); end
    for i in 1:TOTAL_ASSETS; write(io, "    alpha_bar_ik_$i delta_ik_$i b_bar_$i phi_$i\n"); end
    write(io, ";\n\n")

    # C. PARAMETERS ASSIGNMENT
    write(io, "// --- CALIBRATION ---\n")
    for (k,v) in GLOBAL_PARAMS; write(io, "$k = $v;\n"); end
    write(io, "\n")
    
    for k in 1:N_GROUPS
        write(io, "rho_k$k = $(GROUP_RHO[k]); alpha_bar_k$k = $(GROUP_ALPHA_BAR[k]); delta_k$k = $(GROUP_DELTA[k]);\n")
    end
    write(io, "\n")

    for k in 1:N_GROUPS
        indices = get_group_range(k)
        for i in indices
            local_i = get_local_index(i)
            write(io, "alpha_bar_ik_$i = $(ASSET_ALPHA_BAR[k][local_i]); delta_ik_$i = $(ASSET_DELTA[k][local_i]);\n")
            write(io, "b_bar_$i = $(ASSET_SUPPLY[k][local_i]); phi_$i = $(ASSET_PHI[k][local_i]);\n")
        end
    end
    write(io, "\n")

    # D. MODEL BLOCK
    write(io, "model;\n")
    write(io, "    c = y;\n\n")

    # 1. Shocks
    for i in 1:TOTAL_ASSETS
        write(io, "    omega_G_$i = rho_G * omega_G_$i(-1) + sig_G * eps_G_$i;\n")
        write(io, "    omega_a_$i = rho_a * omega_a_$i(-1) + sig_a * eps_a_$i;\n")
    end
    for k in 1:N_GROUPS
        write(io, "    omega_a_group_$k = rho_a * omega_a_group_$k(-1) + sig_a * eps_a_group_$k;\n")
    end
    write(io, "\n")

    # 2. Aggregators
    sum_L = build_summation(1:N_GROUPS, k -> "(alpha_k$k * L_k$k^((eta-1)/eta))")
    write(io, "    L = ( $sum_L )^(eta/(eta-1));\n")

    for k in 1:N_GROUPS
        indices = get_group_range(k)
        sum_Lk = build_summation(indices, i -> "(alpha_ik_$i * b_$i^((rho_k$k-1)/rho_k$k))")
        write(io, "    L_k$k = ( $sum_Lk )^(rho_k$k/(rho_k$k-1));\n")
    end
    
    # 3. Weights
    denom_k = build_summation(1:N_GROUPS, j -> "(alpha_bar_k$j * exp(delta_k$j * omega_a_group_$j))")
    for k in 1:N_GROUPS
        num_k = "(alpha_bar_k$k * exp(delta_k$k * omega_a_group_$k))"
        write(io, "    alpha_k$k = $num_k / ( $denom_k );\n")
    end

    for k in 1:N_GROUPS
        indices = get_group_range(k)
        denom_ik = build_summation(indices, j -> "(alpha_bar_ik_$j * exp(delta_ik_$j * omega_a_$j))")
        for i in indices
            num_ik = "(alpha_bar_ik_$i * exp(delta_ik_$i * omega_a_$i))"
            write(io, "    alpha_ik_$i = $num_ik / ( $denom_ik );\n")
        end
    end
    write(io, "\n")

    # 4. FOCs & Supply
    for i in 1:TOTAL_ASSETS
        k = get_asset_group(i)
        
        write(io, "    b_$i = b_bar_$i + phi_$i * omega_G_$i;\n")
        

        
        
        lhs = "1 - beta * R_$i" 
        
        weights = "alpha_k$k * alpha_ik_$i"
        agg_L   = "L^(1/eta - gamma)"
        agg_Lk  = "L_k$k^(1/rho_k$k - 1/eta)"
        own_b   = "b_$i^(-1/rho_k$k)"
        rhs = "(psi / c^(-sigma)) * $weights * $agg_L * $agg_Lk * $own_b"
        
        write(io, "    $lhs = $rhs;\n")
        
    
    end
    write(io, "end;\n\n")

    # E. INITIALIZATION
    write(io, "initval;\n")
    write(io, "    c = y; L = 1.0;\n")
    for i in 1:TOTAL_ASSETS; write(io, "    omega_G_$i = 0; omega_a_$i = 0;\n"); end
    for k in 1:N_GROUPS; write(io, "    omega_a_group_$k = 0;\n"); end
    
    for k in 1:N_GROUPS
        write(io, "    L_k$k = 1.0; alpha_k$k = $(GROUP_ALPHA_BAR[k]);\n")
    end
    
    for k in 1:N_GROUPS
        indices = get_group_range(k)
        for i in indices
            local_i = get_local_index(i)
            write(io, "    b_$i = $(ASSET_SUPPLY[k][local_i]);\n")
            write(io, "    alpha_ik_$i = $(ASSET_ALPHA_BAR[k][local_i]);\n")
            # CHANGED: Initialize R directly
            write(io, "    R_$i = 1.0/beta - 0.005;\n")
        end
    end
    write(io, "end;\n\n")

    # F. SOLVE
    write(io, "shocks;\n")
    for i in 1:TOTAL_ASSETS; write(io, "    var eps_G_$i = 1; var eps_a_$i = 1;\n"); end
    for k in 1:N_GROUPS; write(io, "    var eps_a_group_$k = 1;\n"); end
    write(io, "end;\n\n")
    
    write(io, "steady;\ncheck;\n")
    write(io, "stoch_simul(order=1, irf=20, graph_format=pdf);\n")
end

println("Success! Created $MOD_FILENAME ")

# install dynare
# using Pkg
# pkg"add Dynare"



# update dynare
# using Pkg
# pkg"update"



using Dynare
context = @dynare  "LnR_model.mod";